<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë°”ì´ë¸Œ ì˜¤ëª© (19x19 & Exact 5)</title>
    <style>
        body {
            font-family: 'Pretendard', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
        }

        h1 {
            color: #1f2937;
            margin-bottom: 10px;
        }

        .status-bar {
            background-color: white;
            padding: 10px 30px;
            border-radius: 50px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .turn-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .turn-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            border: 1px solid rgba(0,0,0,0.2);
        }

        .black-turn { background-color: black; }
        .white-turn { background-color: white; }

        .timer {
            color: #ef4444;
            font-variant-numeric: tabular-nums;
            min-width: 60px;
        }

        /* ë°”ë‘‘íŒ ì˜ì—­ */
        .board-container {
            position: relative;
        }

        .board-wrapper {
            position: relative;
            padding: 20px;
            background-color: #dcb35c; /* ë‚˜ë¬´ ìƒ‰ìƒ */
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            background-image: linear-gradient(45deg, rgba(0,0,0,0.03) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.03) 75%, rgba(0,0,0,0.03)), 
                              linear-gradient(45deg, rgba(0,0,0,0.03) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.03) 75%, rgba(0,0,0,0.03));
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        canvas {
            cursor: pointer;
            display: block;
        }

        /* ì„¤ì • ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }

        .setup-panel {
            background-color: white;
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 300px;
        }

        .setup-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .setup-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #374151;
        }

        .setup-group select {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
        }

        .controls {
            margin-top: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            background-color: #4b5563;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button.primary-btn {
            background-color: #2563eb;
            width: 100%;
            padding: 12px;
            font-size: 1.1rem;
        }

        button:hover {
            filter: brightness(0.9);
        }

        /* ì•Œë¦¼ ëª¨ë‹¬ */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ef4444;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 100;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(10px);
        }
        
        .toast-info {
            background-color: #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

    </style>
</head>
<body>

    <h1>ë°”ì´ë¸Œ ì˜¤ëª© (19ì¤„)</h1>
    
    <div class="status-bar">
        <div class="turn-info">
            <span id="turnIndicator" class="turn-indicator black-turn"></span>
            <span id="statusText">ì„¤ì • ëŒ€ê¸° ì¤‘...</span>
        </div>
        <div class="timer" id="timerDisplay">30s</div>
    </div>

    <div class="board-container">
        <div class="board-wrapper">
            <canvas id="omokBoard" width="600" height="600"></canvas>
        </div>
        
        <!-- ì„¤ì • ëª¨ë‹¬ -->
        <div id="setupModal" class="modal-overlay">
            <div class="setup-panel">
                <h2 style="margin-top:0;">ê²Œì„ ì„¤ì •</h2>
                
                <div class="setup-group">
                    <label>âš« í‘ëŒ (ì„ ê³µ)</label>
                    <select id="blackPlayerType">
                        <option value="human">ì‚¬ëŒ (Player)</option>
                        <option value="ai">AI (ì»´í“¨í„°)</option>
                    </select>
                </div>

                <div class="setup-group">
                    <label>âšª ë°±ëŒ (í›„ê³µ)</label>
                    <select id="whitePlayerType">
                        <option value="human" selected>ì‚¬ëŒ (Player)</option>
                        <option value="ai">AI (ì»´í“¨í„°)</option>
                    </select>
                </div>

                <button class="primary-btn" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
            </div>
        </div>
    </div>

    <div class="controls">
        <button onclick="showSetup()">ë©”ë‰´ / ì¬ì‹œì‘</button>
    </div>

    <div id="toast" class="toast">ê²½ê³  ë©”ì‹œì§€</div>

    <script>
        const canvas = document.getElementById('omokBoard');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('statusText');
        const turnIndicator = document.getElementById('turnIndicator');
        const toast = document.getElementById('toast');
        const setupModal = document.getElementById('setupModal');
        const timerDisplay = document.getElementById('timerDisplay');

        // ê²Œì„ ì„¤ì • ìƒìˆ˜
        const BOARD_SIZE = 19;
        const CELL_SIZE = 30;
        const PADDING = 30; 
        const TIME_LIMIT = 30; // 30ì´ˆë¡œ ë³€ê²½
        
        // ìƒíƒœ ë³€ìˆ˜
        let board = []; 
        let currentPlayer = 1; // 1: í‘, 2: ë°±
        let gameActive = false;
        let players = { 1: 'human', 2: 'human' };

        // ì• ë‹ˆë©”ì´ì…˜ ë³€ìˆ˜
        let animatingStone = null; // {x, y, player, startTime}
        let animationFrameId = null;

        // íƒ€ì´ë¨¸ ë³€ìˆ˜
        let timeLeft = TIME_LIMIT;
        let timerInterval = null;

        // ì´ˆê¸° í™”ë©´ ê·¸ë¦¬ê¸°
        drawBoardBackground();

        // ê²Œì„ ì‹œì‘ í•¨ìˆ˜
        function startGame() {
            const blackType = document.getElementById('blackPlayerType').value;
            const whiteType = document.getElementById('whitePlayerType').value;

            players = {
                1: blackType,
                2: whiteType
            };

            setupModal.style.display = 'none';
            initBoard();
        }

        function showSetup() {
            stopTimer();
            gameActive = false;
            setupModal.style.display = 'flex';
        }

        // ì´ˆê¸°í™”
        function initBoard() {
            board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(0));
            currentPlayer = 1;
            gameActive = true;
            animatingStone = null;
            updateStatus("í‘ëŒ ì°¨ë¡€ì…ë‹ˆë‹¤");
            
            drawBoard();
            processTurn();
        }

        // í„´ ì²˜ë¦¬
        function processTurn() {
            if (!gameActive) return;

            stopTimer();
            startTimer();

            const type = players[currentPlayer];

            if (type === 'ai') {
                canvas.style.cursor = 'wait';
                setTimeout(makeAiMove, 700);
            } else {
                canvas.style.cursor = 'pointer';
            }
        }

        // íƒ€ì´ë¨¸ ë¡œì§
        function startTimer() {
            timeLeft = TIME_LIMIT;
            updateTimerDisplay();
            
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();

                if (timeLeft <= 0) {
                    stopTimer();
                    const loser = currentPlayer === 1 ? 'í‘ëŒ' : 'ë°±ëŒ';
                    const winner = currentPlayer === 1 ? 'ë°±ëŒ' : 'í‘ëŒ';
                    showToast(`â° ì‹œê°„ ì´ˆê³¼! ${winner} ìŠ¹ë¦¬!`, true);
                    updateStatus(`${winner} ìŠ¹ë¦¬ (ì‹œê°„ ì´ˆê³¼)`);
                    gameActive = false;
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateTimerDisplay() {
            timerDisplay.textContent = `${timeLeft}s`;
            if (timeLeft <= 10) {
                timerDisplay.style.color = '#dc2626';
                timerDisplay.style.fontWeight = '900';
            } else {
                timerDisplay.style.color = '#1f2937';
                timerDisplay.style.fontWeight = 'bold';
            }
        }

        // ==========================================
        //  ê·¸ë˜í”½ & ì• ë‹ˆë©”ì´ì…˜
        // ==========================================

        function drawBoard() {
            drawBoardBackground();

            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    if (board[y][x] !== 0) {
                        if (animatingStone && animatingStone.x === x && animatingStone.y === y) {
                            continue; 
                        }
                        drawStone(x, y, board[y][x], 1.0); 
                    }
                }
            }

            if (animatingStone) {
                const elapsed = Date.now() - animatingStone.startTime;
                const duration = 200; 
                let progress = elapsed / duration;
                
                const stoneToDraw = animatingStone;

                if (progress > 1) {
                    progress = 1;
                    animatingStone = null; 
                    cancelAnimationFrame(animationFrameId); 
                } else {
                    animationFrameId = requestAnimationFrame(drawBoard);
                }

                let scale = 1.5 - (0.5 * progress); 
                
                ctx.globalAlpha = Math.min(1, progress * 1.5);
                drawStone(stoneToDraw.x, stoneToDraw.y, stoneToDraw.player, scale);
                ctx.globalAlpha = 1.0;
            }
        }

        function drawBoardBackground() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = "#dcb35c";
            ctx.fillRect(0,0,canvas.width, canvas.height);

            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#000';

            for (let i = 0; i < BOARD_SIZE; i++) {
                ctx.moveTo(PADDING, PADDING + i * CELL_SIZE);
                ctx.lineTo(PADDING + (BOARD_SIZE - 1) * CELL_SIZE, PADDING + i * CELL_SIZE);
                ctx.moveTo(PADDING + i * CELL_SIZE, PADDING);
                ctx.lineTo(PADDING + i * CELL_SIZE, PADDING + (BOARD_SIZE - 1) * CELL_SIZE);
            }
            ctx.stroke();

            const dots = [3, 9, 15];
            ctx.fillStyle = '#000';
            dots.forEach(x => {
                dots.forEach(y => {
                    ctx.beginPath();
                    ctx.arc(PADDING + x * CELL_SIZE, PADDING + y * CELL_SIZE, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            });
        }

        function drawStone(x, y, player, scale = 1.0) {
            const centerX = PADDING + x * CELL_SIZE;
            const centerY = PADDING + y * CELL_SIZE;
            const radius = (CELL_SIZE / 2 - 2) * scale;

            ctx.beginPath();
            ctx.arc(centerX, centerY, Math.max(0, radius), 0, Math.PI * 2);

            const gradient = ctx.createRadialGradient(
                centerX - radius/3, centerY - radius/3, radius/10,
                centerX, centerY, radius
            );

            if (player === 1) { 
                gradient.addColorStop(0, '#555');
                gradient.addColorStop(1, '#000');
            } else { 
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(1, '#ddd');
            }

            const shadowOffset = 2 * scale;
            const shadowBlur = 4 * scale;

            ctx.save();
            ctx.shadowColor = 'rgba(0,0,0,0.4)';
            ctx.shadowBlur = shadowBlur;
            ctx.shadowOffsetX = shadowOffset;
            ctx.shadowOffsetY = shadowOffset;
            
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();
        }

        // í´ë¦­ ì´ë²¤íŠ¸
        canvas.addEventListener('click', (e) => {
            if (!gameActive) return;
            if (players[currentPlayer] === 'ai') return; 

            const rect = canvas.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left - PADDING) / CELL_SIZE);
            const y = Math.round((e.clientY - rect.top - PADDING) / CELL_SIZE);

            placeStone(x, y);
        });

        function placeStone(x, y) {
            if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return;
            if (board[y][x] !== 0) return;

            if (currentPlayer === 1) {
                const forbiddenType = checkForbidden(x, y, 1);
                if (forbiddenType > 0) {
                    if (players[1] === 'human') {
                        showToast(`âš ï¸ ${forbiddenType === 33 ? '3-3' : '4-4'} ê¸ˆìˆ˜ì…ë‹ˆë‹¤!`);
                    }
                    return;
                }
            }

            board[y][x] = currentPlayer;

            animatingStone = {
                x: x,
                y: y,
                player: currentPlayer,
                startTime: Date.now()
            };
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            drawBoard(); 

            if (checkWin(x, y, currentPlayer)) {
                stopTimer();
                showToast(`ğŸ‰ ${currentPlayer === 1 ? 'í‘ëŒ' : 'ë°±ëŒ'} ìŠ¹ë¦¬!`, true);
                updateStatus(`${currentPlayer === 1 ? 'í‘ëŒ' : 'ë°±ëŒ'} ìŠ¹ë¦¬!`);
                gameActive = false;
                return;
            }

            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateStatus(currentPlayer === 1 ? "í‘ëŒ ì°¨ë¡€ì…ë‹ˆë‹¤" : "ë°±ëŒ ì°¨ë¡€ì…ë‹ˆë‹¤");
            
            processTurn(); 
        }

        // ==========================================
        //  AI ë¡œì§
        // ==========================================
        function makeAiMove() {
            if (!gameActive) return;

            let bestScore = -Infinity;
            let bestMoves = [];
            const center = Math.floor(BOARD_SIZE / 2);

            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    if (board[y][x] === 0) {
                        if (currentPlayer === 1 && checkForbidden(x, y, 1) > 0) continue;
                        if (!hasNeighbor(x, y) && (x!==center || y!==center)) continue;

                        const score = evaluatePosition(x, y, currentPlayer);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMoves = [{x, y}];
                        } else if (score === bestScore) {
                            bestMoves.push({x, y});
                        }
                    }
                }
            }

            if (bestMoves.length > 0) {
                bestMoves.sort((a, b) => {
                    const distA = Math.abs(a.x - center) + Math.abs(a.y - center);
                    const distB = Math.abs(b.x - center) + Math.abs(b.y - center);
                    return distA - distB;
                });
                
                const move = bestMoves[0];
                placeStone(move.x, move.y);
            } else {
                placeStone(center, center);
            }
        }

        function hasNeighbor(x, y) {
            const range = 2;
            for(let dy=-range; dy<=range; dy++){
                for(let dx=-range; dx<=range; dx++){
                    if(dx===0 && dy===0) continue;
                    const nx = x+dx, ny = y+dy;
                    if(isValid(nx, ny) && board[ny][nx] !== 0) return true;
                }
            }
            return false;
        }

        function evaluatePosition(x, y, color) {
            const opponent = color === 1 ? 2 : 1;
            let attackScore = getLineScore(x, y, color);
            let defenseScore = getLineScore(x, y, opponent);
            
            return attackScore + (defenseScore * 0.95); 
        }

        function getLineScore(x, y, color) {
            let totalScore = 0;
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];

            board[y][x] = color; 

            for (let [dx, dy] of directions) {
                const count = countConsecutive(x, y, dx, dy, color);
                const openEnds = countOpenEnds(x, y, dx, dy, color, count);

                if (count === 5) totalScore += 100000; // ì •í™•íˆ 5ê°œ ìŠ¹ë¦¬
                else if (count > 5) totalScore -= 1000; // 6ëª© ì´ìƒì€ ìŠ¹ë¦¬ê°€ ì•„ë‹˜ (ì˜¤íˆë ¤ ì†í•´ì¼ ìˆ˜ ìˆìŒ)
                else if (count === 4) {
                    if (openEnds >= 1) totalScore += 5000;
                    if (openEnds === 2) totalScore += 7000;
                }
                else if (count === 3) {
                    if (openEnds === 2) totalScore += 1000;
                    else if (openEnds === 1) totalScore += 100;
                }
                else if (count === 2) {
                    if (openEnds === 2) totalScore += 50;
                    else if (openEnds === 1) totalScore += 10;
                }
            }

            board[y][x] = 0; 
            return totalScore;
        }

        // ==========================================
        //  ìœ í‹¸ë¦¬í‹° ë° íŒì • ë¡œì§
        // ==========================================
        function updateStatus(msg) {
            statusText.textContent = msg;
            turnIndicator.className = 'turn-indicator ' + (currentPlayer === 1 ? 'black-turn' : 'white-turn');
        }

        function showToast(msg, isSuccess = false) {
            toast.textContent = msg;
            toast.className = 'toast show';
            if (isSuccess) toast.classList.add('toast-info');
            else toast.classList.remove('toast-info');
            setTimeout(() => { toast.className = 'toast'; }, 3000);
        }

        const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];

        function countConsecutive(x, y, dx, dy, color) {
            let count = 1;
            let i = 1;
            // ë°©í–¥ 1 íƒìƒ‰ (ì œí•œ ì—†ìŒ)
            while (isValid(x + dx * i, y + dy * i) && board[y + dy * i][x + dx * i] === color) {
                count++;
                i++;
            }
            i = 1;
            // ë°©í–¥ 2 íƒìƒ‰ (ì œí•œ ì—†ìŒ)
            while (isValid(x - dx * i, y - dy * i) && board[y - dy * i][x - dx * i] === color) {
                count++;
                i++;
            }
            return count;
        }

        function checkWin(x, y, color) {
            for (let [dx, dy] of directions) {
                // ì •í™•íˆ 5ê°œì¼ ë•Œë§Œ ìŠ¹ë¦¬ (6ëª© ì´ìƒì€ ìŠ¹ë¦¬ ì•„ë‹˜)
                if (countConsecutive(x, y, dx, dy, color) === 5) return true;
            }
            return false;
        }

        function checkForbidden(x, y, color) {
            if (color !== 1) return 0; 
            let threeCount = 0;

            board[y][x] = color;
            for (let [dx, dy] of directions) {
                const lineInfo = getLineInfo(x, y, dx, dy, color);
                if (lineInfo.isOpenThree) threeCount++;
            }
            board[y][x] = 0;
            
            if (threeCount >= 2) return 33; 
            return 0;
        }

        function getLineInfo(x, y, dx, dy, color) {
            let lineStr = "";
            for (let i = -4; i <= 4; i++) {
                const nx = x + dx * i, ny = y + dy * i;
                if (!isValid(nx, ny)) lineStr += "3"; 
                else if (i === 0) lineStr += "1"; 
                else {
                    const val = board[ny][nx];
                    lineStr += val === color ? "1" : (val === 0 ? "0" : "2");
                }
            }
            
            const consecutive = countConsecutive(x, y, dx, dy, color);
            const openEnds = countOpenEnds(x, y, dx, dy, color, consecutive);

            let isOpenThree = false;
            if (consecutive === 3 && openEnds === 2) {
                if (lineStr.includes("01110")) isOpenThree = true;
            }
            if (checkGapThree(lineStr)) isOpenThree = true;

            return { isOpenThree };
        }

        function isValid(x, y) {
            return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;
        }

        function countOpenEnds(x, y, dx, dy, color, len) {
            let opens = 0;
            let i = 1;
            while(isValid(x + dx*i, y + dy*i) && board[y+dy*i][x+dx*i] === color) i++;
            if (isValid(x + dx*i, y + dy*i) && board[y+dy*i][x+dx*i] === 0) opens++;
            let j = 1;
            while(isValid(x - dx*j, y - dy*j) && board[y-dy*j][x-dx*j] === color) j++;
            if (isValid(x - dx*j, y - dy*j) && board[y-dy*j][x-dx*j] === 0) opens++;
            return opens;
        }

        function checkGapThree(str) {
            if (/010110/.test(str) || /011010/.test(str)) return true;
            return false;
        }

    </script>
</body>
</html>